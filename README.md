# Skye

Skye is a live coding framework and point cloud viewer using a progressive rendering method that allows viewing any point cloud that fits in GPU memory in real time without the need to create hierarchical acceleration structures in advance. 

* The rendering engine is implemented in Javascript (using V8) and code can be modified at runtime. Saving a *.js file via ctrl+s will immediately execute it and subsequently replace old code with the new one. 
* The javascript engine is backed by a C++ and OpenGL core. JS bindings exist for most OpenGL functions. Some performance sensitive parts may be written entirely in C++.
* It's relatively easy to implement your own functionality in C++ and write a JS binding to it. Check V8Helper.cpp for some examples. There are also examples like _readFileAsync_ for bindings that return promises, and therefore allow you to execute C++ code in parallel threads and invoke a callback / resolve the promise in JS once the thread finishes.


 It's being developed at the [Research Division of Computer Graphics, TU Wien](https://www.cg.tuwien.ac.at/)  

Video (YouTube):

<a href="https://www.youtube.com/watch?v=6_ivIcynok8" target="_blank">
	<img src="./resources/images/video_preview.jpg" />
</a>

## Getting Started

### Install

Open Skye.sln and compile the project in Release mode. 

Then, open the workspace in [Visual Studio Code](https://code.visualstudio.com/) by right clicking an empty region, then selecting "Open with Code". Start the application from vscode by pressing __ctrl+shift+b__.

### Things to do

Most JS script files are executed on save (ctrl+s). Take a look at __start.js__ (use ctrl+e to find files). This file is only executed once at startup, but all the files that are executed by watchJS() inside start.js are monitored and executed on save. 

In order to view one of your own point clouds, open "benchmark_heidentor_progressive.js" and change the load command to ```let las = loadLASProgressive("C:/my_pointcloud.las");```. Once you save the file with ctrl+s, the file will be loaded. At the moment, only LAS is supported. Check the console for potential errors. Use the scroll wheel to zoom in or out, the left mouse button to rotate around the center of view, and the right mouse button to move the camera left/right/up/down. 

The heart of the rendering engine are the update() and render() functions as defined in update.js and render.js. These two functions are called from the underlying C++ code each frame. 

The JS to C++ OpenGL bindings are defined in _V8Helper.cpp_ and _V8GLExtBindings.cpp_. The latter is mostly automatically generated by _createBindings.js_. Bindings to OpenVR are located in _V8VR.cpp_.

## Limitations

This project is an early prototype that is super unstable. It works, but you should expect crashes, bugs and frequent breaking changes as it is updated.

## License

This project is licensed under the 2-Clause BSD License, see LICENSE.txt.
Some parts of the engine, mainly the math classes is *src_js/math*, are heavily inspired and partially taken from [three.js](https://github.com/mrdoob/three.js/), which is available under the [MIT License](https://github.com/mrdoob/three.js/blob/dev/LICENSE).

## References

Following publications are based on this project:

* *Progressive Real-Time Rendering of One Billion Points Without Hierarchical Acceleration Structures*, Markus Schütz, Gottfried Mandlburger, Johannes Otepka, Michael Wimmer, to be published
* *Live Coding of a VR Render Engine in VR*, Markus Schütz, Michael Wimmer, IEEE VR 2019 Poster
* *Real-Time Continuous Level of Detail Rendering of Point Clouds*, Markus Schütz, Katharina Krösl, Michael Wimmer, IEEE VR 2019 Paper
